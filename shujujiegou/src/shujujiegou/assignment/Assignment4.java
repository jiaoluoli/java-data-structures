package shujujiegou.assignment;
//李俊杰2016202307   2018/10/25

import shujujiegou.entity.Elem;
import shujujiegou.entity.LinkedList;
import shujujiegou.entity.Maze;
import shujujiegou.entity.Tree;

public class Assignment4 {
	public static void main(String[] args) {
		//开始执行时间
		long startTime=System.currentTimeMillis();
		//maze最外面一层必须封闭，即全为1
		/*int[][] maze = {{1,1,1,1,1,1,1,1,1,1},{1,0,0,1,0,0,0,1,0,1},{1,0,0,1,0,0,0,1,0,1},{1,0,0,0,0,1,1,0,0,1},{1,0,1,1,1,0,0,0,0,1},{1,0,0,0,1,0,0,0,0,1},{1,0,1,0,0,0,1,0,0,1},{1,0,1,1,1,0,1,1,0,1},{1,1,0,0,0,0,0,0,0,1},{1,1,1,1,1,1,1,1,1,1}};
		int[][] mazeshow = {{1,1,1,1,1,1,1,1,1,1},{1,0,0,1,0,0,0,1,0,1},{1,0,0,1,0,0,0,1,0,1},{1,0,0,0,0,1,1,0,0,1},{1,0,1,1,1,0,0,0,0,1},{1,0,0,0,1,0,0,0,0,1},{1,0,1,0,0,0,1,0,0,1},{1,0,1,1,1,0,1,1,0,1},{1,1,0,0,0,0,0,0,0,1},{1,1,1,1,1,1,1,1,1,1}};*/
		int[][] maze = {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1},{1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1},{1,1,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1,0,0,1,1,1},{1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,1},{1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1},{1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1},{1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,1,1,0,0,0,0,1,1},{1,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,0,1,1},{1,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1},{1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1},{1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},{1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};
		int[][] mazeshow = {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1},{1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1},{1,1,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1,0,0,1,1,1},{1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,1},{1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1},{1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1},{1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,1,1,0,0,0,0,1,1},{1,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,0,1,1},{1,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1},{1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1},{1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},{1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};
		//每个Elem中存储data=[x坐标,y坐标,出栈后该前进方向]  next=出栈后的Elem
		Maze mazeer = new Maze();
		Elem start = new Elem();
		Elem end = new Elem();
		//开始坐标，第一个数字为x坐标，第二个数字为y坐标，例如maze3[10][28]输入data时为[28,10]
		int[] st = {1,7};
		//目的地坐标
		int[] et = {28,10};
		//如果输入坐标有错，不再进行
		if(st[0] < 0 || st[1] < 0 || et[0] < 0 || et[1] <0 || st[0] > maze[0].length-1 || st[1] > maze.length-1 || et[0] > maze[0].length || et[1] > maze.length) {
			System.out.println("输入坐标不在迷宫范围");
			return;
		}
		if(maze[st[1]][st[0]] == 1 || maze[et[1]][et[0]] == 1) {
			System.out.println("输入坐标有障碍物");
			return; 
		}
/*		//基于深度算法使用栈的方式走出迷宫
		int[] startst = new int[3];
		System.arraycopy(st, 0, startst, 0, 2);
		start.data = startst;
		end.data = et;
		LinkedList goThrough = mazeer.goThrough(start, end, maze);
		if(goThrough != null) {
			goThrough.displayElem().forEach(elem->{
				mazeshow[elem.data[1]][elem.data[0]] = 2;
			});
			for(int i = 0; i < mazeshow.length; i++) {
				for(int j = 0; j < mazeshow[0].length; j++) {
					System.out.print(mazeshow[i][j]);
				}
				System.out.println();
			}
		}else System.out.println("无法到达终点");*/
		
		//基于广度算法使用tree走出迷宫
		start.data = st;
		end.data = et;
		Tree goThrough1 = mazeer.goThrough1(start, end, maze);
		Elem lastElem = goThrough1.getLastElem().get(0);
		if(lastElem.data != null) {
			goThrough1.displayElem(lastElem).forEach(elem->{
				mazeshow[elem.data[1]][elem.data[0]] = 2;
			});
			for(int i = 0; i < mazeshow.length; i++) {
				for(int j = 0; j < mazeshow[0].length; j++) {
					System.out.print(mazeshow[i][j]);
				}
				System.out.println();
			}
		}else System.out.println("无法到达终点");
		//结束执行时间
		long endTime=System.currentTimeMillis();
		//程序用时
		System.out.println("程序运行时间： "+(endTime-startTime)+"ms");
		
	}

}

